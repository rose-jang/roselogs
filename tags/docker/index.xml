<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docker on Rose Jang</title><link>https://rose-jang.github.io/roselogs/tags/docker/</link><description>Recent content in Docker on Rose Jang</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 26 Feb 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://rose-jang.github.io/roselogs/tags/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker Basics</title><link>https://rose-jang.github.io/roselogs/p/docker-basics/</link><pubDate>Wed, 26 Feb 2025 00:00:00 +0000</pubDate><guid>https://rose-jang.github.io/roselogs/p/docker-basics/</guid><description>&lt;img src="https://rose-jang.github.io/roselogs/p/docker-basics/docker-banner.png" alt="Featured image of post Docker Basics" />&lt;p>I journaled about the basics of Docker in this post. Starting with a brief overview of what docker is and concept of containerization. I delve into how containerization differs from traditional software deployment methods and conclude with a walkthrough of creating docker images and containers.&lt;/p>
&lt;h1 id="what-is-docker">What is Docker?
&lt;/h1>&lt;p>&lt;strong>&lt;code>Docker&lt;/code>&lt;/strong> is an open-source containerization platform (PaaS) that enables users to package applications along with their required dependencies into lightweight, portable containers. It simplifies application deployment and execution, making it a popular choice for modern software delivery.&lt;/p>
&lt;hr>
&lt;h2 id="why-docker">Why Docker?
&lt;/h2>&lt;h3 id="benefits">Benefits
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Efficiency&lt;/strong>
Docker streamlines the deployment process with &lt;strong>pre-built images, reducing the complexity&lt;/strong> of setting up environments from scratch. Containers save time and resources by eliminating the need for running a full operating system for each application.&lt;/li>
&lt;li>&lt;strong>Portability&lt;/strong>
Docker&amp;rsquo;s Platform-agnostic containers provide consistent performance across various environments. Known for the resolution of &amp;ldquo;It works on my machine&amp;rdquo;, &lt;strong>containers can run anywhere, not just on a local machine&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;h3 id="virtualization-vs-containerization">Virtualization VS Containerization
&lt;/h3>&lt;p>Virtualization is a technique that enables the execution of an entire operating system on a physical host using a &lt;strong>hypervisor&lt;/strong>, such as &lt;code>Hyper-V&lt;/code> or &lt;code>VMware&lt;/code>. This allows multiple virtual machines to &lt;strong>run independently on its own resources&lt;/strong> while being able to intercommunicate with each other.&lt;/p>
&lt;p>Containerization on the other hand, focuses on packaging applications with their dependencies into containers that &lt;strong>share the resources of the host system&lt;/strong>. Containers are more lightweight than VMs because they &lt;strong>don&amp;rsquo;t require a full OS to run&lt;/strong>. Instead, they run in isolated environments on the host operating system.&lt;/p>
&lt;h1 id="core-concepts">Core Concepts
&lt;/h1>&lt;h2 id="behind-the-scenes-how-docker-operates">Behind-the-Scenes: How Docker Operates
&lt;/h2>&lt;p>Docker&amp;rsquo;s powerful functionality stems from its core framework, &lt;strong>Docker Engine&lt;/strong> that enables containerization. The combination of docker components allows Docker to pull base images from repositories, create containers, and manage them seamlessly.&lt;/p>
&lt;h3 id="docker-engine-components">Docker Engine Components
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Docker Host&lt;/strong>: Where the host system provides hardware resources to support operations.&lt;/li>
&lt;li>&lt;strong>Docker Daemon&lt;/strong> (&lt;code>dockerd&lt;/code>): Primary component that listens and processes user requests, and also responsible for managing images and containers.&lt;/li>
&lt;li>&lt;strong>Docker CLI&lt;/strong>: The interface users interact for communicating with the Docker system conveniently. CLI interprets user commands into API requests for Docker Daemon.&lt;/li>
&lt;li>&lt;strong>REST API&lt;/strong>: A stateless API enabling communication between the CLI and Docker Daemon to process and fulfill user requests.&lt;/li>
&lt;/ul>
&lt;h3 id="a-little-more-about-rest-api">A little more about REST API&amp;hellip;
&lt;/h3>&lt;ul>
&lt;li>REST API is used for session communication between the user and the Docker Daemon. The Docker Daemon listens for REST API requests via &lt;code>docker.sock&lt;/code> or over HTTP(S)/TCP protocols. Since REST APIs are stateless, they do not retain information about previous requests; each request is independent. This stateless nature works because the user includes all necessary information in each request to ensure it can be fulfilled without relying on prior context.&lt;/li>
&lt;/ul>
&lt;h3 id="docker-engine-workflow">Docker Engine Workflow
&lt;/h3>&lt;ol>
&lt;li>User initiates Docker (run via CLI or program).&lt;/li>
&lt;li>Docker Daemon (dockerd) functions and listens for REST API requests via local socket or remote TCP socket.&lt;/li>
&lt;li>User sends requests via CLI, which interprets the commands and forwards them as REST API requests to the Docker Daemon.&lt;/li>
&lt;li>Docker Daemon processes the request and performs the desired action (e.g., creating a container, displays running containers).&lt;/li>
&lt;li>User can then interact with Docker resources and experience the Docker system.&lt;/li>
&lt;/ol>
&lt;h3 id="cross-platform-operation">Cross-Platform Operation
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Docker Desktop&lt;/strong>: Enables to run Linux based Docker system on Windows or macOS without additional emulation features.&lt;/li>
&lt;li>&lt;strong>WSL Integration&lt;/strong>: Integrating Docker Desktop with the &lt;code>WSL (Windows Subsystem for Linux)&lt;/code> optimizes performances providing a native-like Linux environment for Windows users.&lt;/li>
&lt;/ul>
&lt;h2 id="try-dockerfile">Try Dockerfile
&lt;/h2>&lt;ol>
&lt;li>Start with &lt;strong>base images&lt;/strong> available online such as &lt;code>Docker Hub&lt;/code>&lt;/li>
&lt;li>Create &lt;strong>custom images&lt;/strong> by writing a &lt;code>Dockerfile&lt;/code> script&lt;/li>
&lt;li>The custom images are used to create &amp;amp; run containers&lt;/li>
&lt;li>Containers operate in an isolated environment
&lt;ul>
&lt;li>Runs separately from the host system&lt;/li>
&lt;li>Still relies on the host&amp;rsquo;s resources (CPU, memory, storage, &amp;hellip;)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="image">Image
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Image&lt;/strong> is a static template used to create a container, which is editable and usable multiple times.&lt;/li>
&lt;li>Edit &lt;code>Dockerfike&lt;/code> if any updates needed for applications, very convenient &amp;amp; efficient way for development and deployment.&lt;/li>
&lt;/ul>
&lt;h3 id="container---port">Container - Port
&lt;/h3>&lt;p>When running a container, you get to configure port numbers. There are 2 port numbers which are used on host and container respectively.&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>-p host-port:container-port&lt;/code>&lt;/p>&lt;/blockquote>
&lt;ul>
&lt;li>&lt;code>host-port&lt;/code> is opened externally for incoming traffics.&lt;/li>
&lt;li>&lt;code>container-port&lt;/code> is at the door of containers listening to connections.&lt;/li>
&lt;li>Basically they map each other as you configured at container build.&lt;/li>
&lt;/ul>
&lt;h3 id="create-a-dockerfile">Create a Dockerfile
&lt;/h3>&lt;ol>
&lt;li>Specify and provide requirements in a &lt;code>Dockerfile&lt;/code>
&lt;ul>
&lt;li>Define a desired base image&lt;/li>
&lt;li>Write required configurations, dependencies, or libraries&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> image:tag&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> apt-get update &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> apt-get install -y nginx&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> ./webServer&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> ./web.sh&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> ./conf.sh&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ol start="2">
&lt;li>Run the &lt;code>Dockerfile&lt;/code> to create a container
&lt;code>docker -t image:tag directoryOfDockerfile&lt;/code>
&lt;code>docker -t webApp:first .&lt;/code>
-&amp;gt; then Docker installs the listed dependencies or packages&lt;/li>
&lt;li>Run the container
&lt;code>docker run -p 5000:443 --name myContainer webApp:first&lt;/code>&lt;/li>
&lt;/ol>
&lt;h3 id="dockerfile---best-practice">Dockerfile - Best practice
&lt;/h3>&lt;ol>
&lt;li>Minimize image size
&lt;ul>
&lt;li>Use base images with the minimalist &lt;code>alpine&lt;/code> Linux distribution&lt;/li>
&lt;li>Install without cache using the flag &lt;code>--no-cache-dir&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Keep the script clean
&lt;ul>
&lt;li>List a required dependencies in a file (.txt)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-dockerfile" data-lang="dockerfile">&lt;span class="line">&lt;span class="cl">&lt;span class="k">FROM&lt;/span>&lt;span class="s"> python:3.10-alpine&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">WORKDIR&lt;/span>&lt;span class="s"> /kube-WebApp&lt;/span>&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> requirements.txt /kube-WebApp&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">RUN&lt;/span> pip install -r dependencies.txt --no-cache-dir&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">COPY&lt;/span> . /kube-WebApp&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&lt;/span>&lt;span class="k">CMD&lt;/span> python app.py&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item></channel></rss>